<html>
<head>
    <title>Akka and Spray</title>
</head>
<body>
<div>
    <h2>Akka and Spray</h2>

    <p>
        This application shows how to build Akka application with Spray API. In this tutorial, I 
        are going to use Spray's <code>spray-can</code>, <code>spray-httpx</code>, 
        <code>spray-json</code> artefacts with the <em>Akka</em> artefacts to build an application
        that receives HTTP requests with JSON payloads, unmarshals the JSON into instances of our
        own classes (<code>case class</code>es, to be exact). It then sends these instances to the
        appropriate <code>Actor</code>s for processing. When the actors reply, it marshals the 
        responses into JSON, and uses that to construct the HTTP responses.
    </p>
    <p>
        I shall also explore the <em>Cake pattern</em>, which enable us to separate out parts of the
        system so that I can "assemble" the parts of the cake into the components that I ultimately
        run or test.
    </p>
    <p>
        <img src="overall.png" title="Overall structure"/>
    </p>

    <p>
        In this template &amp; tutorial, you will learn how to construct <a href="#">TODO: Akka</a>-based
        applications; how to test them (using <a href="#">TODO: TestKit</a> and <a href="#">TODO: Specs2</a>;
        and how to provide RESTful HTTP API using <a href="#">TODO: Spray</a>.
    </p>
</div>
<div>
    <h2>The core</h2>
    <p>
        I begin by constructing the core of our system. It contains the top-level
        <code>MessengerActor</code> and <code>RegistrationActor</code>. The
        <code>MessengerActor</code> contains two child actors, the <code>EmailActor</code> and
        the <code>SMSActor</code>.
    </p>
    <p>
        The top-level actors <em>live</em> in the <code>CoreActors</code> trait. This trait's
        <a href="#">TODO: self-type annotation</a> defines that instances that mix in this trait
        must also mix in some subtype of the <code>Core</code> trait.<br/>
        This is a rather long description of the first two lines of the <code>CoreActors</code> trait.
<pre><code>
trait CoreActors {
  this: Core =>

}
</code></pre>
        Because of the self-type declaration, I have access to all members of the <code>Core</code>
        trait in the <code>CoreActors</code> trait. Our <code>Core</code> trait defines only one
        member, namely <code>implicit def system: ActorSystem</code>; and I use the <code>system</code>
        to create the top-level actors.
    </p>
    <p>
        The <code>CoreActor</code> in its entirety is therefore
<pre><code>
trait CoreActors {
  this: Core =>

  val registration = system.actorOf(Props[RegistrationActor])
  val messenger    = system.actorOf(Props[MessengerActor])

}
</code></pre>
    </p>
    <p>
        I also provide the implementation of the <code>Core</code> trait that actually constructs
        the <code>ActorSystem</code>. I call this trait <code>BootedCore</code>. It instantiates the
        <code>ActorSystem</code> and registers the JVM termination hook to shutdown the <code>ActorSystem</code>
        on JVM exit.
<pre><code>
trait BootedCore extends Core {

  implicit val system = ActorSystem("akka-spray")

  sys.addShutdownHook(system.shutdown())

}
</code></pre>
        As you can see, the <code>BootedCore</code> is a straight-forward implementation of the
        <code>Core</code> trait.
    </p>

    <p>
        If I now wanted, I could write a simple application that starts our actors by
        mixing in the traits.
<pre><code>
object Cli extends App with BootedCore with CoreActors
</code></pre>
        I must be mindful of the initialization order, though. It would be an error to
        write <code>object Cli extends App with CoreActors with BootedCore</code>!<br/>
        It is because the <code>BootedCore</code>'s implementation of the <code>system</code>
        method is <code>implicit val system = ActorSystem("akka-spray")</code> and if
        I write <code>object Cli extends App with CoreActors with BootedCore</code>, the
        code in <code>CoreActors</code> runs before the code in <code>BootedCore</code>--meaning
        that when the code in <code>CoreActors</code> runs, the value of the <code>system</code>
        <code>val</code> is still <code>null</code>.
    </p>

    <p>
        Having to worry about the order in which I mix in the traits is wholly unsatisfactory.
        I need to find a way in which a <code>val</code> can be evaluated immediately when
        its value is required, but once it is evaluated, it behaves like an ordinary <code>val</code>.
        Rephrasing, I want a member whose value will be computed and remembered on first access, and
        subsequent accesses will return the remembered value.
        <br/>
        To do this in Scala, I mark the <code>val</code> as <code><em>lazy</em></code>. Thus, our
        <code>BootedCore</code>'s <code>system</code> becomes
<pre><code>
trait BootedCore extends Core {

  implicit lazy val system = ActorSystem("akka-spray")

  sys.addShutdownHook(system.shutdown())

}
</code></pre>
        Notice the <code>lazy</code> keyword--now I are free to mix in the required traits
        in any order.
    </p>
</div>
<div>
    <h2>Testing</h2>

    <p>
        Let's now explore why I did so much code gymnastics. I could have just as easily
        defined the <code>CoreActors</code> trait to contain all the code in <code>Core</code> and
        <code>BootedCore</code>.
    </p>

    <p>
        The motivation was testing. When I are using Akka's <a href="#">TODO: TestKit</a>, we
        construct a test-only <code>ActorSystem</code>. This testing <code>ActorSystem</code>
        allows us to test the actors as if the messages sent and received were method
        calls. In other words, the <code>ActorSystem</code> in our tests uses the
        <code>CallingThreadDispatcher</code>, making the message delivery synchronous.
    </p>

    <p>
        As it happens, the <code>TestKit</code> contains a member called <code>system: ActorSystem</code>;
        and it matches the <code>Core</code> trait. Therefore, it is easy to make our <em>specification</em>
        implement the <code>Core</code> trait. This in turn means that our test satisfies the self-type
        annotation of the <code>CoreActors</code> trait.<br/>
        And thus, I can easily write a test for our entire application's structure.
<pre><code>
class RegistrationActorSpec extends TestKit(ActorSystem()) with SpecificationLike with CoreActors with Core {
  ...
}
</code></pre>
        I extend the <code>TestKit</code> class, which gives us access to all the underlying Akka's test
        mechanisms; I also mix in <a href="#">TODO: Specs2</a>'s <code>SpecificationLike</code>, which gives
        us the convenient DSL for writing our test scenarios and assertions. Finally, because I am writing code
        to test <em>my</em> actors, I mix in the <code>CoreActors</code> and <code>Core</code> traits.
        I do not need to do any more work, because the member <code>system: ActorSystem</code> fully implements
        the <code>Core</code> trait. However, I need to implement the <code>Core</code> trait to satisfy the
        self-type declaration of the <code>CoreActors</code>.
    </p>

    <p>
        I could have defined <code>Core</code> to be <a href="#">TODO: structural type</a>, in which case,
        I would not have to worry about implementing <code>Core</code> here. If you want to try it out,
        remove the <code>trait Core { ... }</code> and replace it with
<pre><code>
package object core {

  type Core = { def system: ActorSystem }

}
</code></pre>
        Here, the <code>Core</code> type is a <em>structural type</em>, which says that
        <code>Core</code> is anything which contains the <code>system: ActorSystem</code> member.
    </p>
</div>
<div>
    <h2>The actors</h2>

    <p>
        The implementation of the actors is not particularly interesting. I will explore the
        common patterns of naming and structuring that I believe are useful; the implementation
        of the actors I leave to the readers.
    </p>

    <p>
        I begin with the <code>RegistrationActor</code>. Its purpose is to register the users in our
        system. The actor's <a href="#">TODO: companion object</a> holds all the messages that the
        actor deals with. In code, the structure is
<pre><code>
object RegistrationActor {
  case class Register(user: User)
  case object Registered
  case object NotRegistered
}

class RegistrationActor extends Actor {
  import RegistrationActor._

  def receive: Receive = ???
}
</code></pre>
        This structure allows me to tidy up the messages and perhaps some utility functions
        in the future from the actor itself.
    </p>
    <p>
        Onwards to the actor's implementation, then. As I said, it will be rather trivial,
        mainly demonstrating approaches &amp; patterns. When it receives the <code>Register</code>
        message, it performs the required processing and then replies to the <em>sender</em> with
        the outcome of the registration process.
<pre><code>
class RegistrationActor extends Actor{
import RegistrationActor._

  def receive: Receive = {
    case Register(user) if user.email.isEmpty => sender ! Left(NotRegistered)
    case Register(user)                       => sender ! Right(Registered)
  }

}
</code></pre>
        I warned you, it is not very clever at all :).
    </p>
</div>
<div>
    <h2>Testing the <code>RegistrationActor</code></h2>

    <p>
        As simple as the <code>RegistrationActor</code> is, we can (and <em>should</em>) still test it.
        We can either test the actor in isolation, writing a <em>unit test</em>, or we can test our
        entire application, but focusing on the <code>RegistrationActor</code>--an <em>integration test</em>.<br/>
        I will show the integration test approach here.
    </p>

    <p>
        To allow us to examine what happens in our actors, we need to use special--<em>crippled</em>--
        <code>ActorSystem</code> that processes the messages synchronously. To the code, then. We
        extend the <code>TestKit</code> class and mix in the required traits to construct the test.
<pre><code>
class RegistrationActorSpec extends TestKit(ActorSystem()) with SpecificationLike with CoreActors with Core {
  sequential

  private def mkUser(email: String): User = User(UUID.randomUUID(), "A", "B", email)

  "Registration should" >> {

    "reject invalid email" in {
      registration ! Register(mkUser(""))
      expectMsg(Left(NotRegistered))
      success
    }

    "accept valid user to be registered" in {
      registration ! Register(mkUser("jan@eigengo.com"))
      expectMsg(Right(Registered))
      success
    }
  }

}
</code></pre>
        This is the entire body of our test. I instantiate the actors in <code>CoreActors</code>,
        satisfying the <code>Core</code> self-type annotation by having the <code>RegistrationActorSpec</code>
        implement the <code>Core</code> trait. (Remember, I can do that just by writing <code>with Core</code>,
        because <code>TestKit</code> already contains the member <code>system: ActorSystem</code>, which is
        all that is needed to fully implement <code>Core</code>.)
    </p>

    <p>
        Onwards. If you run the test, it will fail. It will complain about failing timeouts, namely
<pre><code>
assertion failed: timeout (3 seconds) during expectMsgClass waiting for class core.RegistrationActor$NotRegistered$
</code></pre>
        And yet, if you place a breakpoint in the <code>RegistrationActor</code>'s <code>receive</code>,
        you will see that it is indeed executing; replying to the <code>sender</code> with the appropriate
        message.<br/>
        The only conclusion is that the <code>sender</code> itself is somehow broken. Indeed. Going back to our
        test, I write <code>registration ! Register(mkUser(""))</code>. If you explore the <code>!</code>
        function, you will see that it is a curried function, whose first parameter list is the
        message to be sent, and its second parameter list is the <code>ActorRef</code> which represents
        the sender. It is marked as <code>implicit</code>, but it also contains a <em>default value</em>.
        So, if no <code>ActorRef</code> instance is available implicitly, the default value will be used
        instead. Unfortunately for me here, the default value is <code>Actor.noSender</code>.
    </p>

    <p>
        To fix the problem, all I need to do is have an implicit <code>ActorRef</code> value. However,
        this <code>ActorRef</code> should also somehow interact with the rest of the code in TestKit.
        Furtunately for the lazy, TestKit provides the <code>ImplicitSender</code> trait, which makes
        the <code>testActor</code> implicitly available; and the <code>testActor</code> interacts with
        all the <code>expect...</code> functions in TestKit.
<pre><code>
class RegistrationActorSpec extends TestKit(ActorSystem()) with SpecificationLike with CoreActors with Core with ImplicitSender {
   ...
}
</code></pre>
        I mix in the <code>ImplicitSender</code> and all is good!
    </p>
</div>
<div>
    <h2>Spray</h2>
    <p>
        We are going to use most of the Spray components, namely
        <ul>
            <li><code>spray-io</code> for the low-level, asynchronous I/O,</li>
            <li><code>spray-http</code> for the HTTP protocol implementation on top of <code>spray-io</code>,</li>
            <li><code>spray-routing</code>, which provides convenient DSL for mapping HTTP requests to functions,</li>
            <li><code>spray-httpx</code> for the unmarshalling and marshalling of the HTTP requests and responses,</li>
            <li><code>spray-json</code> for JSON marshallers and unmarshallers</li>
        </ul>
        This feels like quite a handful, but you will see that the code is rather succinct and,
        of course, type safe. Even more importantly, the Spray code does not interfere with the
        core of our system. The core can remain completely oblivious of the way in which it is
        exposed.
    </p>

    <p>
        I continue to strictly separate the layers of (even if so trivial) application; therefore,
        I will separate the REST API from the code that starts the HTTP server hosting the API.
        In keeping with the rest of the system, I will split the layers into traits, giving me
        the <code>Api</code> and <code>Web</code> traits. As you can guess, the <code>Api</code> trait
        contains just the REST API, and the <code>Web</code> trait exposes the APIs in a real
        HTTP server.<br/>
        To make the <code>Api</code> trait work with the rest of the system, I will use the self-type
        annotation and require that the <code>Api</code> trait is mixed in with <code>CoreActors</code>
        and <code>Core</code>. The <code>Web</code> trait will need to be mixed in with <code>Api</code>.
<pre><code>
trait Api {
  this: CoreActors with Core =>

  ...
}
</code></pre>
        And
<pre><code>
trait Web {
  this: Api with CoreActors with Core =>

  ...
}
</code></pre>
        All of this to enable me to write tests that exercise just the REST API, without the need
        to start the HTTP server and deal with the added complexity of real HTTP requests; and to
        allow me to write a subtype of <code>App</code> that combines all the components
        and starts a real HTTP server; server, which hosts the API, which in turn uses the core
        actors to do the heavy processing. In code, the <em>entire</em> application is just one line:
<pre><code>
object Rest extends App with BootedCore with CoreActors with Api with Web
</code></pre>
        <em>Amazing!</em>
    </p>
</div>
<div>
    <h2>The API</h2>
    <p>
        Let's explore the <code>Api</code> trait, which defines the REST endpoints. In keeping with the
        structure from the diagram, I have kept each endpoint in its own class. The <code>Api</code> trait
        constructs the classes for these endpoints and then concatenates the routes they each expose.
        The <code>RoutedHttpService</code> then routes the incoming HTTP requests accordingly.
<pre><code>
trait Api extends RouteConcatenation {
  this: CoreActors with Core =>

  private implicit val _ = system.dispatcher

  val routes =
    new RegistrationService(registration).route ~
    new MessengerService(messenger).route

  val rootService = system.actorOf(Props(new RoutedHttpService(routes)))

}
</code></pre>
        I instantiate the <code>RegistrationService</code> and the <code>MessengerService</code>, giving
        each reference to the approprite <code>ActorRef</code> from the <code>CoreActors</code>. (I can do
        this, because the <code>Api</code> trait declares the <code>CoreActors</code> as its self-type.)
    </p>
</div>
<div>
    <h2>Registration Service</h2>

    <p>
        I will show the code and structure of the <code>RegistrationService</code>, which is ever so
        slightly more complex than the code in <code>MessengerService</code>. The motivation for the
        <code>RegistrationService</code> is to have REST API that receives JSON payloads in that can
        be mapped to instances of the <code>Register</code> case class.
<pre><code>
{ "user": {
    "id": "122fa630-92fd-11e2-9e96-0800200c9a66",
    "firstName":"Jan",
    "lastName":"Machacek",
    "email":"jan@eigengo.com" } }
</code></pre>
        I expect replies to match the responses (<code>Either[NotRegistered, Registered]</code>);
        the value on the left projection should result in HTTP status <em>bad request</em>; the
        value on the right projection should be HTTP OK.
    </p>

    <p>

    </p>
</div>
</body>
</html>
